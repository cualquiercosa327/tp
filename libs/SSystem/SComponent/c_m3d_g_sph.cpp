/* c_m3d_g_sph.cpp autogenerated by split.py v0.3 at 2021-01-01 14:53:31.074880 */

#include "SComponent/c_m3d_g_sph.h"
#include "SComponent/c_m3d.h"

// SetC__8cM3dGSphFRC4cXyz
void cM3dGSph::SetC(const cXyz& pCenter) {
    mCenter = pCenter;
}

// Set__8cM3dGSphFRC4cXyzf
void cM3dGSph::Set(const cXyz& pCenter, float pRadius) {
    this->SetC(pCenter);
    this->SetR(pRadius);
}

// Set__8cM3dGSphFRC9cM3dGSphS
void cM3dGSph::Set(const cM3dGSphS& other) {
    this->SetC(cXyz(other.mCenter));
    this->SetR(other.mRadius);
}

// SetR__8cM3dGSphFf
void cM3dGSph::SetR(float pRadius) {
    mRadius = pRadius;
}

// cross__8cM3dGSphCFPC8cM3dGSphP4cXyz
bool cM3dGSph::cross(const cM3dGSph* other, cXyz* out) const {
    return cM3d_Cross_SphSph(other, this, out);
}

// cross__8cM3dGSphCFPC8cM3dGCylP4cXyz
bool cM3dGSph::cross(const cM3dGCyl* cylinder, cXyz* out) const {
    float f;
    return cM3d_Cross_CylSph(cylinder, this, out, &f);
}

// GetMinMaxCube__8cM3dGSphCFR4cXyzR4cXyz
void cM3dGSph::GetMinMaxCube(cXyz& min, cXyz& max) const {
    min.x = mCenter.x - mRadius;
    min.y = mCenter.y - mRadius;
    min.z = mCenter.z - mRadius;
    max.x = mCenter.x + mRadius;
    max.y = mCenter.y + mRadius;
    max.z = mCenter.z + mRadius;
}
